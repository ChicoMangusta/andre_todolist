{"ast":null,"code":"//REACT HOOKS\n//============================================================\nimport { useState, useEffect } from 'react';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers';\nimport moment from \"moment\";\nexport const useTasks = selectProject => {\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n  useEffect(() => {\n    let unsubscribe = firebase.firestore().collection('tasks').where('userId', '==', 'bart1104'); // Go to Firebase and use my ID == this\n\n    unsubscribe = selectProject && !collatedTasksExist(selectProject) ? unsubscribe = unsubscribe.where('projectId', '==', selectProject) : selectProject === 'TODAY' ? unsubscribe = unsubscribe.where('date', '==', moment().format('DD/MM/YYYY')) : //moment() to manage time zones\n    selectProject === 'INBOX' || selectProject === 0 ? unsubscribe = unsubscribe.where('date', '==', '') : unsubscribe; // GO THRU ALL THE TASKS AND SELECT THE KEY AND GIVE ME THE PROJECTS\n\n    unsubscribe = unsubscribe.onSnapshot(snapshot => {\n      const newTask = snapshot.docs.map(task => ({\n        id: task.id,\n        ...task.data()\n      }));\n      setTasks(selectedProject === \"NEXT_7\" ? newTasks.filter(task => moment(task.date, \"DD-MM-YYYY\").diff(moment(), \"days\") <= 7 && //.diff() is the difference between two dates in days\n      task.archived !== true) : newTasks.filter(task => task.archived !== true));\n      setArchivedTasks(newTasks.filter(task => task.archived !== false)); // show all the tasks that are true\n    });\n    return () => unsubscribe();\n  }, [selectProject]); //when this changes re-run all the above functions\n\n  return {\n    tasks,\n    archivedTasks\n  };\n};\nexport const useProjects = () => {\n  const [projects, setProjects] = useState([]);\n  useEffect(() => {\n    firebase.firestore() //go to firestore\n    .collection('projects') // get collection, projects\n    .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw') // set the user ID\n    .orderBy('projectId') //order by the ID of the project\n    .get() //get  \n    .then(snapshot => {\n      // data from a database location\n      const allProjects = snapshot.docs.map(project => ({ //map through the database of all projects\n        ...project.data(),\n        docId: project.id //docId is in case we want to delete somthing\n\n      }));\n\n      if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n        setProjects(allProjects); // this is to avoid infite loop, because the function is checking its self, calling its self all the time it changes\n      }\n    });\n  }, [projects]);\n  return {\n    projects,\n    setProjects\n  };\n};","map":{"version":3,"sources":["/Users/mang/Desktop/DEV/unit_5/project_5_final/andre_todolist/src/hooks/index.js"],"names":["useState","useEffect","firebase","collatedTasksExist","moment","useTasks","selectProject","tasks","setTasks","archivedTasks","setArchivedTasks","unsubscribe","firestore","collection","where","format","onSnapshot","snapshot","newTask","docs","map","task","id","data","selectedProject","newTasks","filter","date","diff","archived","useProjects","projects","setProjects","orderBy","get","then","allProjects","project","docId","JSON","stringify"],"mappings":"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","sourcesContent":["//REACT HOOKS\n//============================================================\n\nimport { useState, useEffect } from 'react';\nimport { firebase } from '../firebase'\nimport { collatedTasksExist } from '../helpers';\nimport moment from \"moment\";\n\n\nexport const useTasks = selectProject => {\n    const [tasks, setTasks] = useState([]);\n    const [archivedTasks, setArchivedTasks] = useState([]);\n    \n\n    useEffect(() => {\n        let unsubscribe = firebase\n        .firestore()\n        .collection('tasks')\n        .where('userId', '==', 'bart1104');// Go to Firebase and use my ID == this\n\n\n        unsubscribe = selectProject && !collatedTasksExist(selectProject) ? \n        (unsubscribe = unsubscribe.where('projectId', '==', selectProject)) \n        : selectProject === 'TODAY'\n        ? (unsubscribe = unsubscribe.where('date', '==', moment().format('DD/MM/YYYY')))//moment() to manage time zones\n        : selectProject === 'INBOX' || selectProject === 0 \n        ? (unsubscribe = unsubscribe.where('date', '==', '')) \n        :unsubscribe;// GO THRU ALL THE TASKS AND SELECT THE KEY AND GIVE ME THE PROJECTS\n\n    unsubscribe = unsubscribe.onSnapshot((snapshot) => {\n      const newTask = snapshot.docs.map((task) => ({\n        id: task.id,\n        ...task.data(),\n      }));\n\n      setTasks(\n        selectedProject === \"NEXT_7\"\n          ? newTasks.filter(\n              (task) =>\n                moment(task.date, \"DD-MM-YYYY\").diff(moment(), \"days\") <= 7 && //.diff() is the difference between two dates in days\n                task.archived !== true\n            )\n          : newTasks.filter((task) => task.archived !== true)\n      );\n      setArchivedTasks(newTasks.filter((task) => task.archived !== false));// show all the tasks that are true\n    });\n\n    return () => unsubscribe();\n\n    }, [selectProject]);//when this changes re-run all the above functions\n\n\n    return { tasks, archivedTasks };\n};\n\n\nexport const useProjects = () => {\n  const [projects, setProjects] = useState([]);\n\n  useEffect(() => {\n    firebase\n      .firestore() //go to firestore\n      .collection('projects') // get collection, projects\n      .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw') // set the user ID\n      .orderBy('projectId') //order by the ID of the project\n      .get() //get  \n      .then(snapshot => {// data from a database location\n        const allProjects = snapshot.docs.map(project => ({ //map through the database of all projects\n          ...project.data(),\n          docId: project.id, //docId is in case we want to delete somthing\n        }));\n\n        if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n          setProjects(allProjects); // this is to avoid infite loop, because the function is checking its self, calling its self all the time it changes\n        }\n      });\n  }, [projects]);\n\n  return { projects, setProjects };\n};"]},"metadata":{},"sourceType":"module"}
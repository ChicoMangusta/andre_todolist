{"ast":null,"code":"//REACT HOOKS\n//============================================================\nimport { useState, useEffect } from 'react';\nimport moment from 'moment';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers'; //============================================================\n\nexport const useTasks = selectedProject => {\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n  useEffect(() => {\n    let unsubscribe = firebase.firestore().collection('tasks').where('userId', '==', 'bart1104'); // Go to Firebase and use my ID == this\n\n    unsubscribe = selectedProject && !collatedTasksExist(selectedProject) ? unsubscribe = unsubscribe.where('projectId', '==', selectedProject) : selectedProject === 'TODAY' ? unsubscribe = unsubscribe.where('date', '==', moment().format('DD/MM/YYYY')) : //moment() to manage time zones\n    selectedProject === 'INBOX' || selectedProject === 0 ? unsubscribe = unsubscribe.where('date', '==', '') : unsubscribe; // GO THRU ALL THE TASKS AND SELECT THE KEY AND GIVE ME THE PROJECTS\n\n    unsubscribe = unsubscribe.onSnapshot(snapshot => {\n      const newTasks = snapshot.docs.map(task => ({\n        id: task.id,\n        ...task.data()\n      }));\n      setTasks(selectedProject === 'NEXT_7' ? newTasks.filter(task => moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 && //.diff() is the difference between two dates in days\n      task.archived !== true) : newTasks.filter(task => task.archived !== true));\n      setArchivedTasks(newTasks.filter(task => task.archived !== false)); // show all the tasks that are true\n    });\n    return () => unsubscribe();\n  }, [selectedProject]); //when this changes re-run all the above functions\n\n  return {\n    tasks,\n    archivedTasks\n  };\n};\nexport const useProjects = () => {\n  const [projects, setProjects] = useState([]);\n  useEffect(() => {\n    firebase.firestore() //go to firestore\n    .collection('projects') // get collection, projects\n    .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw') // set the user ID\n    .orderBy('projectId') //order by the ID of the project\n    .get() //get  \n    .then(snapshot => {\n      // data from a database location\n      const allProjects = snapshot.docs.map(project => ({ //map through the database of all projects\n        ...project.data(),\n        docId: project.id //docId is in case we want to delete somthing\n\n      }));\n\n      if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n        setProjects(allProjects); // this is to avoid infite loop, because the function is checking its self, calling its self all the time it changes\n      }\n    });\n  }, [projects]);\n  return {\n    projects,\n    setProjects\n  };\n};","map":{"version":3,"sources":["/Users/mang/Desktop/DEV/unit_5/project_5_final/andre_todolist/src/hooks/index.js"],"names":["useState","useEffect","moment","firebase","collatedTasksExist","useTasks","selectedProject","tasks","setTasks","archivedTasks","setArchivedTasks","unsubscribe","firestore","collection","where","format","onSnapshot","snapshot","newTasks","docs","map","task","id","data","filter","date","diff","archived","useProjects","projects","setProjects","orderBy","get","then","allProjects","project","docId","JSON","stringify"],"mappings":"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","sourcesContent":["//REACT HOOKS\n//============================================================\n\nimport { useState, useEffect } from 'react';\nimport moment from 'moment';\nimport { firebase } from '../firebase';\nimport { collatedTasksExist } from '../helpers';\n//============================================================\n\n\nexport const useTasks = selectedProject => {\n  const [tasks, setTasks] = useState([]);\n  const [archivedTasks, setArchivedTasks] = useState([]);\n\n  useEffect(() => {\n    let unsubscribe = firebase\n      .firestore()\n      .collection('tasks')\n      .where('userId', '==', 'bart1104');// Go to Firebase and use my ID == this\n\n\n        unsubscribe = selectedProject && !collatedTasksExist(selectedProject) ? \n        (unsubscribe = unsubscribe.where('projectId', '==', selectedProject)) \n        : selectedProject === 'TODAY'\n        ? (unsubscribe = unsubscribe.where('date', '==', moment().format('DD/MM/YYYY')))//moment() to manage time zones\n        : selectedProject === 'INBOX' || selectedProject === 0 \n        ? (unsubscribe = unsubscribe.where('date', '==', '')) \n        :unsubscribe;// GO THRU ALL THE TASKS AND SELECT THE KEY AND GIVE ME THE PROJECTS\n\n    unsubscribe = unsubscribe.onSnapshot((snapshot) => {\n      const newTasks = snapshot.docs.map((task) => ({\n        id: task.id,\n        ...task.data(),\n      }));\n\n      setTasks(\n          selectedProject === 'NEXT_7' ?\n          newTasks.filter(task =>\n          moment(task.date, 'DD-MM-YYYY').diff(moment(), 'days') <= 7 && //.diff() is the difference between two dates in days\n          task.archived !== true): newTasks.filter(task => task.archived !== true));\n                 \n      setArchivedTasks(newTasks.filter((task) => task.archived !== false));// show all the tasks that are true\n    });\n\n\n    return () => unsubscribe();\n    }, [selectedProject]); //when this changes re-run all the above functions\n\n\n    return { tasks, archivedTasks };\n};\n\n\nexport const useProjects = () => {\n  const [projects, setProjects] = useState([]);\n\n  useEffect(() => {\n    firebase\n      .firestore() //go to firestore\n      .collection('projects') // get collection, projects\n      .where('userId', '==', 'jlIFXIwyAL3tzHMtzRbw') // set the user ID\n      .orderBy('projectId') //order by the ID of the project\n      .get() //get  \n      .then(snapshot => {// data from a database location\n        const allProjects = snapshot.docs.map(project => ({ //map through the database of all projects\n          ...project.data(),\n          docId: project.id, //docId is in case we want to delete somthing\n        }));\n\n        if (JSON.stringify(allProjects) !== JSON.stringify(projects)) {\n          setProjects(allProjects); // this is to avoid infite loop, because the function is checking its self, calling its self all the time it changes\n        }\n      });\n  }, [projects]);\n\n  return { projects, setProjects };\n};"]},"metadata":{},"sourceType":"module"}